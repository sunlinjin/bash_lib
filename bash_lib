# begin of bash_lib file

if [ "0" = "${bash_lib_included_flag:-0}" ]; then
    declare -x bash_lib_included_flag=included
else
    echo Warning, Double sourced!
fi

shopt -s expand_aliases

# define for test, due to the function LogPrint can not be multi-sourced
#alias LogPrint='echo this is a test of alias;echo'
alias LogPrint='echo'

# TODO & Bug:
# source this file multi-times, the global readonly definintion will issue errors(20170418)

# Dependency :

# Rules for bash_lib :
# all the following functions and variables are used as libarary, so be careful with the implementation.
# to avoid the name conflict, all the names, which will NOT be used by the caller,
#     only used in this file should be started with the underline character.

# Global definition


### # the following definintion should not add the leading underline, due to the caller need to use them.
### declare -r ECHO="echo" # just to replace echo
### declare -r ERROR="error" # print red color text
### declare -r WARN="warn" # print yellow color text
### declare -r INFO="info" # print green color text
### declare -r MESSAGE="message" # no color
### declare -r SPECIAL="special" # exceptional case, print the specified color test, the color control string should be in the second para.
### declare -r HIGHLIGHT="highlight" #same with sourceInsight, highlight the messages, yellow background and black text
### # Usage : LogPrint [ECHO | ERROR | WARN | INFO | HIGHLIGHT | SPECIAL [| MESSAGE]] "Soft/Hard quoted message content"
### # Usage : LogPrint SPECIAL ColorSetting "Soft/Hard quoted message content, disable sequence will be added automatically."
### function LogPrint()
### {
###     local logLevel="${MESSAGE}"
###     local logContent=""
###     local ColorSetting=""
###
###     if [ $# -ne 0 ]; then
###         case "$1" in
###             "${ECHO}" | "${ERROR}" | "${INFO}" | "${WARN}" | "${MESSAGE}" | "${HIGHLIGHT}" ) logLevel="$1"; shift;;
###             "${SPECIAL}" ) logLevel="$1"; ColorSetting="$2"; shift 2;;
###             * ) logLevel="${MESSAGE}";; # LogPrint "${INFO}" 'No log level specified, use the default value : INFO'
###         esac
###     else
###         LogPrint "${ERROR}" "No Parameter for LogPrint! please check."
###     fi
###
###     logContent="${@}"
###
###     case "${logLevel}" in
###         "${ECHO}"      ) echo ${logContent};;
###         "${ERROR}"     ) echo -e "\033[31m${logContent}\033[0m";;
###         "${WARN}"      ) echo -e "\033[33m${logContent}\033[0m";;
###         "${INFO}"      ) echo -e "\033[32m${logContent}\033[0m";;
###         "${MESSAGE}"   ) echo "${logContent}";;
###         "${SPECIAL}"   ) echo -e "${ColorSetting}${logContent}\033[0m";;
###         "${HIGHLIGHT}" ) echo -e "\033[7m\033[33m${logContent}\033[0m";;
###     esac
###
###     return 0
### }

function IsDigitOnly()
# check if $1 does indeed contain only characters digit, 0-9
{
    local var
    local _returnValue=0

    for var in "$@"; do
        # _LETTERS_ONLY="${var}"
        # _LETTERS_ONLY=`LogPrint $1 | awk '{if($0~/[^a-zA-Z]/) print "1"}'`
        # if [ "$_LETTERS_ONLY" != "" ]; then
        #     LogPrint "input parameter(${var}) contains ${_LETTERS_ONLY}"
        #     _returnValue=1
        # fi

        if [[ ! "${var}" =~ ^[0-9]*$ ]]; then
            LogPrint "${var} is not Digit Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

function IsValidOctal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^[-+]?0[0-7]*$ ]];then
            LogPrint "${var} is not a valid Octal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Octal"
        fi
    done

    return ${_returnValue};
}

function IsValidDecimal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^[-+]?[0-9]*$ ]];then
            LogPrint "${var} is not a valid Decimal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Decimal"
        fi
    done

    return ${_returnValue};
}

function IsValidHexadecimal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^0[xX][0-9a-fA-F]*$ ]];then
            LogPrint "${var} is not a valid Hexadecimal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Hexadecimal"
        fi
    done

    return ${_returnValue};
}

function IsValidNumber()
{
    local var;
    local sign="+";

    # support Octal, decimal, hexadecimal, and sign is allowed.
    for var in "$@";do
        if [[ "${var::1}" =~ ^[-+]$ ]];then
            sign="${var:0:1}"
            var="${var: 1}"
        fi

        if [[ "${var:0:2}" =~ ^0[xX]$ ]];then
            IsValidHexadecimal "${var}"
        elif [[ "${var::1}" = "0" ]];then
            IsValidOctal "${sign}${var}"
        else
            IsValidDecimal "${sign}${var}"
        fi

    done
    return 0
}

declare    g_Index=0
declare -a g_Result=(0)
function TransferToDecimal()
{
    local var
    local _returnValue=0

    g_Index=0
    g_Result=(0)

    for var in "$@";do
        if IsValidHexadecimal "${var}";then
            g_Result[${g_Index}]=$(echo "obase=10;ibase=16;${var}" | bc)
        else
            _returnValue=1
        fi
        if IsValidDecimal "${var}";then
            g_Result[${g_Index}]="${var}"
        else
            _returnValue=1
        fi
        if IsValidDecimal "${var}";then
            g_Result[${g_Index}]=$(echo "obase=10;ibase=8;${var}" | bc)
        else
            _returnValue=1
        fi
        
        if [ ${_returnValue} -ne 0 ] || ! IsValidOctal "${g_Result[${g_Index}]}"; then
            continue
        fi
        ((g_Index=g_Index+1))
    done
    
    echo "${g_Result[@]}"

    return "${_returnValue}";
}

# check if $1 does indeed contain only characters a-z,A-Z
function IsLetterOnly()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^[a-zA-Z]*$ ]]; then
            LogPrint "${var} is not Letter Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

# check if $1 does indeed contain only characters a-z,A-Z,0-9
function IsLetterOrDigitOnly()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^[a-zA-Z0-9]*$ ]]; then
            LogPrint "${var} is not Letter Or Digit Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

# check validation of IP address
function IsValidIP()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
            LogPrint "${var} is not valid a IP address."
            _returnValue=1
        else
            LogPrint match
            LogPrint "${BASH_REMATCH[1]}"
            LogPrint "${BASH_REMATCH[2]}"
            LogPrint "${BASH_REMATCH[3]}"
            LogPrint "${BASH_REMATCH[4]}"
        fi

        # echo $var | grep -E "^[0-9]\{1,3\}\.\([0-9]\{1,3\}\.\)\{2\}[0-9]\{1,3\}$" > /dev/null;
        # #IP address must be all digits
        # if [ $? -ne 0 ]
        # then
            # return 1
        # fi
        # for num in `echo $1 | awk -F. '{print $1, $2, $3, $4}'`
        # do
            # #each num should be [ 0 ~ 255 ]
            # if [ $num -gt 255 ] || [ $num -lt 0 ]
            # then
                # return 1
            # fi
        # done
    done

    return ${_returnValue}
}

# $1 seconds counting down
# $2 display the number, default is display. no_display, disable the number display.
function CountingDown()
{

    if [ $# -lt 1 ] || ! IsDigitOnly "$1" ;then
        LogPrint This function need at least one parameter, counting seconds.
        return 1
    fi

    for ((i = 0; i < $1; i++));do
        if [ "${2:-display}" != "no_display" ];then
            LogPrint -ne "\r$i"
        fi
        sleep 1
    done

    # erase the displayed number, currently 10 spaces erase 10 characters
    LogPrint -ne "\r          \r"

    return 0
}

function __add {  
   LogPrint $[ ${1:-0} + ${2:-0} ]  
}  
  
#乘积  
function __mul {  
   LogPrint $[ ${1:-0} * ${2:-0} ]  
}  
  
#除法  $1 / $2
function __div {  
    if [ ${2:-1} -ne 0 ]  
    then  
        LogPrint $[ ${1:-0} / ${2:-0} ]  
    else  
        LogPrint -1  
    fi  
}  

# end of bash_lib file