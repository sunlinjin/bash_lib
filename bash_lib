# begin of bash_lib file

if [ "0" = "${bash_lib_included_flag:-0}" ]; then
    declare -x bash_lib_included_flag=bash_lib_included
else
    echo "Warning, Double sourced!"
fi

shopt -s expand_aliases

# define for test, due to the function LogPrint can not be multi-sourced
# alias LogPrint='echo this is a test of alias;echo'
alias LogPrint='echo'
# alias LogPrint=':' # mute all display


# TODO & Bug:
# source this file multi-times, the global readonly definintion will issue errors (20170418)
# random number generate function
# funny function like cowsay figlet
# float number calcaulation
# test the number bigger than 32767, what gona happen ?


# Dependency :


# Rules for bash_lib :
# all the following functions and variables are used as libarary, so be careful with the implementation.
# to avoid the name conflict, all the names, which will NOT be used by the caller,
# those who only referenced in this file should be started with the underline.


# Global definition


### # the following definintion should not add the leading underline, due to the caller need to use them.
### declare -r ECHO="echo" # just to replace echo
### declare -r ERROR="error" # print red color text
### declare -r WARN="warn" # print yellow color text
### declare -r INFO="info" # print green color text
### declare -r MESSAGE="message" # no color
### declare -r SPECIAL="special" # exceptional case, print the specified color test, the color control string should be in the second para.
### declare -r HIGHLIGHT="highlight" #same with sourceInsight, highlight the messages, yellow background and black text
### # Usage : LogPrint [ECHO | ERROR | WARN | INFO | HIGHLIGHT | SPECIAL [| MESSAGE]] "Soft/Hard quoted message content"
### # Usage : LogPrint SPECIAL ColorSetting "Soft/Hard quoted message content, disable sequence will be added automatically."
### function LogPrint()
### {
###     local logLevel="${MESSAGE}"
###     local logContent=""
###     local ColorSetting=""
###
###     if [ $# -ne 0 ]; then
###         case "$1" in
###             "${ECHO}" | "${ERROR}" | "${INFO}" | "${WARN}" | "${MESSAGE}" | "${HIGHLIGHT}" ) logLevel="$1"; shift;;
###             "${SPECIAL}" ) logLevel="$1"; ColorSetting="$2"; shift 2;;
###             * ) logLevel="${MESSAGE}";; # LogPrint "${INFO}" 'No log level specified, use the default value : INFO'
###         esac
###     else
###         LogPrint "${ERROR}" "No Parameter for LogPrint! please check."
###     fi
###
###     logContent="${@}"
###
###     case "${logLevel}" in
###         "${ECHO}"      ) echo ${logContent};;
###         "${ERROR}"     ) echo -e "\033[31m${logContent}\033[0m";;
###         "${WARN}"      ) echo -e "\033[33m${logContent}\033[0m";;
###         "${INFO}"      ) echo -e "\033[32m${logContent}\033[0m";;
###         "${MESSAGE}"   ) echo "${logContent}";;
###         "${SPECIAL}"   ) echo -e "${ColorSetting}${logContent}\033[0m";;
###         "${HIGHLIGHT}" ) echo -e "\033[7m\033[33m${logContent}\033[0m";;
###     esac
###
###     return 0
### }

# test command : for var in 1 2 3;do echo ${var};pause;done
function pause()
{
    SAVEDSTTY="$(stty -g)"
    stty -echo
    stty raw
    dd if=/dev/tty bs=1 count=1 2>/dev/null
    stty -raw
    stty echo
    stty $SAVEDSTTY

    # read does this:
    # read -n1 -r -p "Press any key to continue..." key
    # The -n1 specifies that it only waits for a single character. The -r puts it into raw mode, which is necessary because otherwise, if you press something like backslash, it doesn't register until you hit the next key. The -p specifies the prompt, which must be quoted if it contains spaces. The key argument is only necessary if you want to know which key they pressed, in which case you can access it through $key.
    # If you are using Bash, you can also specify a timeout with -t, which causes read to return a failure when a key isn't pressed. So for example :
    # read -t5 -n1 -r -p 'Press any key in the next five seconds...' key
    # if [ "$?" -eq "0" ]; then
        # echo 'A key was pressed.'
    # else
        # echo 'No key was pressed.'
    # fi
    # Strictly speaking, that would be "Enter any non-NUL character to continue". Some keys don't send any character (like Ctrl...) and some send more than one (like F1, Home...). bash ignores NUL characters.

    # -r specifies raw mode, which don't allow combined characters like "\" or "^".
    # -s specifies silent mode, and because we don't need keyboard output.
    # -p $'prompt' specifies the prompt, which need to be between $' and ' to let spaces and escaped characters. Be careful, you must put between single quotes with dollars symbol to benefit escaped characters, otherwise you can use simple quotes.
    # Enter solution, read line, and mute the input char(s) display
    # read -rsp $'Press enter to continue...\n'

    # Escape solution
    # -d $'\e' specifies escappe as delimiter charater, so as a final character for current entry, this is possible to put any character but be careful to put a character that the user can type.
    # read -rsp $'Press escape to continue...\n' -d $'\e'

    # Any key except Ctrl Shift Alt etc.
    # -n 1 specifies that it only needs a single character.
    # read -rsp $'Press any key to continue...\n' -n 1 key
    # echo $key

    # Question with preselected choice, -e specifies readline mode. -i $'Y' specifies Y as initial text in readline mode.
    # -e specifies readline mode.
    # -i $'Y' specifies Y as initial text in readline mode.
    # key serve in case you need to know the input, in -n1 case, the key that has been pressed.
    # read -rp $'Are you sure (Y/n) : ' -ei $'Y' key;
    # echo $key

    # Timeout solution
    # -t 5 specifies a timeout of 5 seconds
    # read -rsp $'Press any key or wait 2 seconds to continue...\n' -n 1 -t 2;

    # Sleep enhanced alias
    # $? serve to know the exit code of the last program, for read, 142 in case of timeout, 0 correct input. Put $? in a variable as soon as possible if you need to test it after somes commands, because all commands would rewrite $?
    # read -rst 3; timeout=$?
    # echo $timeout

    # read -n1 is not portable. A portable way to do the same might be:
    # (   trap "stty $(stty -g;stty -icanon)" EXIT
    # LC_ALL=C dd bs=1 count=1 >/dev/null 2>&1
    # )   </dev/tty
    # Besides using read, for just a press ENTER to continue prompt you could do:
    # sed -n q &>/dev/null </dev/tty

    # read -p "read"

    return 0
}

# RANDOM system variable, range 0-32767
# $1, up limit for the random number, means generate random 0 - $1
function GenRandomNum()
{
    local -i uplimit=${1:-32767}
    local RandomNum=$(( RANDOM % ${uplimit} ))

    # this display should not be muted.
    echo $RandomNum
}

# $1, up limit for the random number, means generate random 0 - $1, default 32767
# $2, element count, default 8
function GenRandomArray()
{
    local -a RandomArray=()
    local -i uplimit=${1:-32767}
    local -i cnt=0

    for ((cnt = 0; cnt < ${2:=8}; cnt++));do
        RandomArray[$cnt]=$(( RANDOM % ${uplimit} ))
    done

    # this display should not be muted.
    echo "${RandomArray[@]}"
}

# $1, length, default 8
function GenRandomString()
{
    local RandomString=""
    # echo $RANDOM | md5sum | cut -c1-8
    # openssl rand -base64 8 | md5sum | cut -c1-8

    local -i  length=${1:-8}
    local -i  i=1
    local -ar seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
    local -r  num_seq=${#seq[@]}

    while [ "$i" -le "${length}" ]; do
        RandomString="${RandomString}${seq[$((RANDOM%num_seq))]}"
        let "i=i+1"
    done

    echo "The random string is: ${RandomString}"

    # this display should not be muted.
    echo $RandomString
}

# default, 8 letters(both upper case and lower case), digits, underline, other chars like $ ^ & etc.
# cover all printable char on the standard key board
function GenRandomPsw()
{
    local RandomPsw=""
    local -i  length=${1:-8}
    local -i  i=1
    local -ar seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \~ \` \! \@ \# \$ \% \^ \& \* \( \) \_ \+ \= \- \| \\ \{ \[ \} \] \' \" \: \; \? \> \. \< \, \/)
    local -r  num_seq=${#seq[@]}

    while [ "$i" -le "${length}" ]; do
        RandomPsw="${RandomPsw}${seq[$((RANDOM%num_seq))]}"
        let "i=i+1"
    done

    echo "The random string is: ${RandomPsw}"

    # this display should not be muted.
    echo $RandomPsw
}

### test command : echo "this is a test" | _color_ blue bold
function _color_()
{
    case "$1" in
        red)    nn="31";;
        green)  nn="32";;
        yellow) nn="33";;
        blue)   nn="34";;
        purple) nn="35";;
        cyan)   nn="36";;
    esac
    ff=""
    case "$2" in
        bold)   ff=";1";;
        bright) ff=";2";;
        uscore) ff=";4";;
        blink)  ff=";5";;
        invert) ff=";7";;
    esac
    color_begin=`echo -e -n "\033[${nn}${ff}m"`
    color_end=`echo -e -n "\033[0m"`
    while read line; do
        echo "${color_begin}${line}${color_end}"
    done
}

function IsDigitOnly()
# check if $1 does indeed contain only characters digit, 0-9
{
    local var
    local _returnValue=0

    for var in "$@"; do
        # _LETTERS_ONLY="${var}"
        # _LETTERS_ONLY=`LogPrint $1 | awk '{if($0~/[^a-zA-Z]/) print "1"}'`
        # if [ "$_LETTERS_ONLY" != "" ]; then
        #     LogPrint "input parameter(${var}) contains ${_LETTERS_ONLY}"
        #     _returnValue=1
        # fi

        if [[ ! "${var}" =~ ^[0-9]*$ ]]; then
            LogPrint "${var} is not Digit Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

function IsValidOctal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^[-+]?0[0-7]*$ ]];then
            LogPrint "${var} is not a valid Octal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Octal"
        fi
    done

    return ${_returnValue};
}

function IsValidDecimal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^[-+]?[0-9]*$ ]];then
            LogPrint "${var} is not a valid Decimal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Decimal"
        fi
    done

    return ${_returnValue};
}

function IsValidHexadecimal()
{
    local var
    local _returnValue=0

    for var in "$@";do
        if [[ ! "${var}" =~ ^0[xX][0-9a-fA-F]*$ ]];then
            LogPrint "${var} is not a valid Hexadecimal"
            _returnValue=1
        else
            LogPrint "${var} is a valid Hexadecimal"
        fi
    done

    return ${_returnValue};
}

function IsValidNumber()
{
    local var;
    local sign="+";

    # support Octal, decimal, hexadecimal, and sign is allowed.
    for var in "$@";do
        if [[ "${var::1}" =~ ^[-+]$ ]];then
            sign="${var:0:1}"
            var="${var: 1}"
        fi

        if [[ "${var:0:2}" =~ ^0[xX]$ ]];then
            IsValidHexadecimal "${var}"
        elif [[ "${var::1}" = "0" ]];then
            IsValidOctal "${sign}${var}"
        else
            IsValidDecimal "${sign}${var}"
        fi

    done
    return 0
}

declare    g_Index=0
declare -a g_Result=(0)
function TransferToDecimal()
{
    local var
    local _returnValue=0

    g_Index=0
    g_Result=(0)

    for var in "$@";do
        if IsValidHexadecimal "${var}";then
            g_Result[${g_Index}]=$(echo "obase=10;ibase=16;${var}" | bc)
        else
            _returnValue=1
        fi
        if IsValidDecimal "${var}";then
            g_Result[${g_Index}]="${var}"
        else
            _returnValue=1
        fi
        if IsValidDecimal "${var}";then
            g_Result[${g_Index}]=$(echo "obase=10;ibase=8;${var}" | bc)
        else
            _returnValue=1
        fi

        if [ ${_returnValue} -ne 0 ] || ! IsValidOctal "${g_Result[${g_Index}]}"; then
            continue
        fi
        ((g_Index=g_Index+1))
    done

    echo "${g_Result[@]}"

    return "${_returnValue}";
}

# check if $1 does indeed contain only characters a-z,A-Z
function IsLetterOnly()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^[a-zA-Z]*$ ]]; then
            LogPrint "${var} is not Letter Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

# check if $1 does indeed contain only characters a-z,A-Z,0-9
function IsLetterOrDigitOnly()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^[a-zA-Z0-9]*$ ]]; then
            LogPrint "${var} is not Letter Or Digit Only"
            _returnValue=1
        fi
    done

    return ${_returnValue}
}

# check validation of IP address
function IsValidIP()
{
    local var
    local _returnValue=0

    for var in "$@"; do
        if [[ ! "${var}" =~ ^([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
            LogPrint "${var} is not valid a IP address."
            _returnValue=1
        else
            LogPrint "${var} is valid IP address, and the match result is :"
            LogPrint "1st section : ${BASH_REMATCH[1]}"
            LogPrint "2nd section : ${BASH_REMATCH[2]}"
            LogPrint "3rd section : ${BASH_REMATCH[3]}"
            LogPrint "4th section : ${BASH_REMATCH[4]}"
        fi

        # echo $var | grep -E "^[0-9]\{1,3\}\.\([0-9]\{1,3\}\.\)\{2\}[0-9]\{1,3\}$" > /dev/null;
        # #IP address must be all digits
        # if [ $? -ne 0 ]
        # then
            # return 1
        # fi
        # for num in `echo $1 | awk -F. '{print $1, $2, $3, $4}'`
        # do
            # #each num should be [ 0 ~ 255 ]
            # if [ $num -gt 255 ] || [ $num -lt 0 ]
            # then
                # return 1
            # fi
        # done
    done

    return ${_returnValue}
}

# limitation : up to 10 digits seconds supported.
# $1 seconds counting down
# $2 display the number, default is display. no_display, disable the number display.
function CountingDown()
{

    if [ $# -lt 1 ] || ! IsDigitOnly "$1" ;then
        LogPrint This function need at least one parameter, counting seconds.
        return 1
    fi

    for ((i = 0; i < $1; i++));do
        if [ "${2:-display}" != "no_display" ];then
            LogPrint -ne "\r$i"
        fi
        sleep 1
    done

    # erase the displayed number, currently 10 spaces erase 10 characters
    LogPrint -ne "\r          \r"

    return 0
}

###################
### Calculation ###
###################

function __add {
   LogPrint $(( ${1:-0} + ${2:-0} ))
}

#乘积
function __mul {
   LogPrint $(( ${1:-0} * ${2:-0} ))
}

#除法  $1 / $2
function __div {
    if [ "${2:-1}" -ne 0 ]
    then
        LogPrint $(( ${1:-0} / ${2:-0} ))
    else
        LogPrint -1
    fi
}

# end of bash_lib file
